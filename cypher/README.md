# 1. Byte数组与十六进制字符串互转

Java中byte用二进制表示占用8位，而我们知道16进制的每个字符需要用4位二进制位来表示。
所以我们就可以把每个byte转换成两个相应的16进制字符，即把byte的高4位和低4位分别转换成相应的16进制字符H和L，并组合起来得到byte转换到16进制字符串的结果`new String(H) + new String(L)`。
 
同理，相反的转换也是将两个16进制字符转换成一个byte，原理同上。
 
根据以上原理，我们就可以将byte[] 数组转换为16进制字符串了，当然也可以将16进制字符串转换为byte[]数组了。  

# 2. BASE64加密解密

Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一，大家可以查看RFC2045～RFC2049，上面有MIME的详细规范。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到。

RFC2045还规定每行位76个字符，每行末尾需添加一个回车换行符，即便是最后一行不够76个字符，也要加换行符。

## 2.1 实现原理

Base64实际上是对二进制码做分组转换操作
1.每3个8位二进制码位一组，转换为4个6位二进制码为一组（不足6位时地位补0）。3个8位二进制码和4个6位二进制码长度都是24位。
2.对获得的4个6位二进制码补位，每个6位二进制码添加两位高位0，组成4个8位二进制码。
3.将获得的4个8位二进制码转换为4个十进制码。
4.将获得的十进制码转换为Base64字符表中对应的字符。

示例：

**1. 字符串“A”，进行Base64编码**

```
字符                A
ASCII码           65
二进制码          01000001
 
4个6位二进制码 010000          010000
4个8位二进制码 00010000       00010000
十进制码          16                 16
字符表映射码     Q                  Q                   =                 =
```
**字符串“A”经过Base64编码后得到字符串“QQ==”。**

结果出现了两个等号。很显然，当原文的二进制码长度不足24位，最终转换为十进制时也不足4项，这时就需要用等号补位。
将Base64编码后的字符串最多会有2个等号，这时因为：
余数 = 原文字节数 MOD 3。

**2. 字符串“密”，进行Base64编码**
```
对其使用UTF-8编码等到Byte数组{-27，-81，-122}，
 
字符                密
UTF-8编码        -27                -81               -122
二进制码          11100101       10101111       10000110
4个6位二进制码 111001          011010           111110          000110
4个8位二进制码 00111001       00011010       00111110       00000110
十进制码          57                 26                  62                6
字符表映射码     5                   a                   +                 G
```
**字符串“密”经过Base64编码后得到字符串“5a+G”。**


## 2.2 对照表

```
索引	对应字符	索引	对应字符	索引	对应字符	索引	对应字符
0	A	17	R	34	i	51	z
1	B	18	S	35	j	52	0
2	C	19	T	36	k	53	1
3	D	20	U	37	l	54	2
4	E	21	V	38	m	55	3
5	F	22	W	39	n	56	4
6	G	23	X	40	o	57	5
7	H	24	Y	41	p	58	6
8	I	25	Z	42	q	59	7
9	J	26	a	43	r	60	8
10	K	27	b	44	s	61	9
11	L	28	c	45	t	62	+
12	M	29	d	46	u	63	/
13	N	30	e	47	v	 	 
14	O	31	f	48	w	 	 
15	P	32	g	49	x	 	 
16	Q	33	h	50	y	 

```

# 3. 消息摘要

消息摘要（Message Digest）又称为数字摘要(Digital Digest)。
它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash加密函数对消息进行作用而产生。如果消息在途中改变了，则接收者通过对收到消息的新产生的摘要与原摘要比较，就可知道消息是否被改变了。因此消息摘要保证了消息的完整性。消息摘要采用单向Hash 函数将需加密 的明文"摘要"成一串128bit的密文，这一串密文亦称为数字指纹(Finger Print)，它有固定的长度，且不同的明文摘要成密文，其结果总是不同的，而同样的明文其摘要必定一致 。这样这串摘要便可成为验证明文是否是"真身"的"指纹"了。 

HASH函数的抗冲突性使得如果一段明文稍有变化，哪怕只更改该段落的一个字母，通过哈希算法作用后都将产生不同的值。而HASH算法的单向性使得要找到到哈希值相同的两个不 同的输入消息，在计算上是不可能的。所以数据的哈希值，即消息摘要，可以检验数据的完整性。哈希函数的这种对不同的输入能够生成不同的值的特性使得无法找到两个具有相同哈希值的输入。因此，如果两个文档经哈希转换后成为相同的值，就可以肯定它们是同一文档。 所以，当希望有效地比较两个数据块时，就可以比较它们的哈希值。例如，可以通过比较邮件发送前和发送后的哈希值来验证该邮件在传递时是否修改。 

## 3.1 消息摘要算法

消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。消息摘要算法不存在 密钥的管理与分发问题，适合于分布式网络相同上使用。由于其加密计算的工作量相当可观，所以以前的这种算法通常只用于数据量有限的情况下的加密，例如计算机的口令就是 用不可逆加密算法加密的。近年来，随着计算机相同性能的飞速改善，加密速度不再成为限制这种加密技术发展的桎梏，因而消息摘要算法应用的领域不断增加。

**消息摘要算法的特点**

1. 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。
2. 消息摘要看起来是“随机的”。这些比特看上去是胡乱的杂凑在一起的。
3. 一般地，只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同；但相同的输入必会产生相同的输出。
4. 消息摘要函数是无陷门的单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。
5. 好的摘要算法，无法找到两条消息，是它们的摘要相同。


**现有的消息摘要算法**

消息摘要算法包含MD、SHA和MAC三大系列，常用于验证数据的完整性，是数据签名算法的核心算法。 

MAC与MD和SHA不同，MAC是含有密钥的散列函数算法，我们也常把MAC称为HMAC。

**JDK对消息摘要算法的支持**

JDK6支持

MD2/MD5/SHA/SHA256/SHA384/SHA512/HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512


